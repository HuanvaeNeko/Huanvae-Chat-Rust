# 文件存储管理 API

## 基础信息

**基础URL**: `http://localhost:8080/api/storage`

## 概述

统一文件存储管理接口，支持文件上传、下载、预览功能。支持小文件直连上传（< 15GB）和超大文件分片上传（> 15GB）。

**✨ UUID映射机制**：采用UUID映射+权限表实现跨用户文件去重，相同文件只存储一份物理副本。

## 核心功能

- ✅ **UUID映射去重**（秒传，跨用户生效）
- ✅ 一次性Token上传（< 15GB）
- ✅ 预签名URL分片上传（> 15GB）
- ✅ 基于权限表的访问控制
- ✅ 智能有效期管理

---

## 1. 请求文件上传

### 接口信息

- **URL**: `/api/storage/upload/request`
- **方法**: `POST`
- **需要鉴权**: 是（Bearer Token）

### 请求参数

```json
{
  "file_type": "user_image",
  "storage_location": "user_files",
  "related_id": null,
  "filename": "example.jpg",
  "file_size": 6400000,
  "content_type": "image/jpeg",
  "file_hash": "abc123...",
  "force_upload": false,
  "estimated_upload_time": 3600
}
```

| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| file_type | string | 是 | 文件类型：user_image, user_video, user_document, friend_image等 |
| storage_location | string | 是 | 存储位置：user_files, friend_messages, group_files, avatars |
| related_id | string | 否 | 关联ID（好友ID或群ID） |
| filename | string | 是 | 原始文件名 |
| file_size | number | 是 | 文件大小（字节） |
| content_type | string | 是 | MIME类型 |
| file_hash | string | 是 | SHA-256哈希值（64位十六进制） |
| force_upload | boolean | 否 | 是否强制上传（跳过秒传），默认false |
| estimated_upload_time | number | 否 | 预计上传时间（秒），仅超大文件需要 |

### 响应示例

**成功响应（一次性Token）**:
```json
{
  "mode": "one_time_token",
  "preview_support": "inline_preview",
  "upload_token": "token_xxx",
  "upload_url": "http://localhost:8080/api/storage/upload/direct?token=xxx",
  "expires_in": 300,
  "presigned_url": null,
  "multipart_upload_id": null,
  "file_key": "user_id/images/timestamp_hash_filename.jpg",
  "max_file_size": 104857600,
  "instant_upload": false,
  "existing_file_url": null
}
```

**秒传响应（UUID映射）**:
```json
{
  "mode": "one_time_token",
  "preview_support": "inline_preview",
  "instant_upload": true,
  "existing_file_url": "http://localhost:8080/api/storage/file/{uuid}",
  "file_key": "user_id/images/..."
}
```

> **重要**: 返回的 `existing_file_url` 是UUID格式的访问路径，不是MinIO直连路径。
> 这样可以实现跨用户去重，相同文件只存储一份。

### Fetch API 调用示例

```javascript
// 计算文件SHA-256哈希
async function calculateSHA256(file) {
  const arrayBuffer = await file.arrayBuffer();
  const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}

// 请求上传
async function requestUpload(file, fileType = 'user_image') {
  const accessToken = localStorage.getItem('access_token');
  
  // 1. 计算文件哈希
  const fileHash = await calculateSHA256(file);
  
  // 2. 请求上传URL
  const response = await fetch('http://localhost:8080/api/storage/upload/request', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      file_type: fileType,
      storage_location: 'user_files',
      filename: file.name,
      file_size: file.size,
      content_type: file.type,
      file_hash: fileHash,
      force_upload: false
    })
  });
  
  const result = await response.json();
  
  // 3. 检查是否秒传
  if (result.instant_upload) {
    console.log('秒传成功！', result.existing_file_url);
    return result;
  }
  
  return result;
}
```

---

## 2. 直接上传文件

### 接口信息

- **URL**: `/api/storage/upload/direct?token={token}`
- **方法**: `POST`
- **需要鉴权**: 否（使用一次性Token）
- **Content-Type**: `multipart/form-data`

### 请求参数

Form Data:
- `file`: 文件数据

### 响应示例

```json
{
  "file_url": "http://localhost:8080/api/storage/file/{uuid}",
  "file_key": "user_id/images/...",
  "file_size": 6400000,
  "content_type": "image/jpeg",
  "preview_support": "inline_preview"
}
```

> **重要**: 返回的 `file_url` 是UUID格式的访问路径，需要通过后端API访问，不是MinIO直连路径。

### Fetch API 调用示例

```javascript
// 上传文件
async function uploadFile(file, uploadUrl) {
  const formData = new FormData();
  formData.append('file', file);
  
  const response = await fetch(uploadUrl, {
    method: 'POST',
    body: formData
    // 注意：不需要Authorization header，Token已在URL中
  });
  
  if (!response.ok) {
    throw new Error('上传失败');
  }
  
  return await response.json();
}
```

---

## 3. 获取分片上传URL（超大文件）

### 接口信息

- **URL**: `/api/storage/multipart/part-url`
- **方法**: `GET`
- **需要鉴权**: 是（Bearer Token）

### 请求参数

Query Parameters:
- `file_key`: 文件key
- `upload_id`: 分片上传ID
- `part_number`: 分片编号（从1开始）

### 响应示例

```json
{
  "part_url": "http://localhost:9000/...",
  "part_number": 1,
  "expires_in": 3600
}
```

### Fetch API 调用示例

```javascript
// 分片上传（超大文件）
async function uploadLargeFile(file, uploadInfo) {
  const accessToken = localStorage.getItem('access_token');
  const chunkSize = 50 * 1024 * 1024; // 50MB
  const chunks = Math.ceil(file.size / chunkSize);
  
  for (let i = 0; i < chunks; i++) {
    const start = i * chunkSize;
    const end = Math.min(start + chunkSize, file.size);
    const chunk = file.slice(start, end);
    
    // 获取分片URL
    const partUrlResponse = await fetch(
      `http://localhost:8080/api/storage/multipart/part-url?file_key=${uploadInfo.file_key}&upload_id=${uploadInfo.multipart_upload_id}&part_number=${i + 1}`,
      {
        headers: {
          'Authorization': `Bearer ${accessToken}`
        }
      }
    );
    
    const { part_url } = await partUrlResponse.json();
    
    // 上传分片
    await fetch(part_url, {
      method: 'PUT',
      body: chunk
    });
    
    console.log(`分片 ${i + 1}/${chunks} 上传完成`);
  }
}
```

---

## 完整上传流程示例

```javascript
// 完整的文件上传流程
async function uploadFileComplete(file) {
  try {
    console.log('开始上传:', file.name);
    
    // 1. 计算文件哈希
    console.log('计算文件哈希...');
    const fileHash = await calculateSHA256(file);
    
    // 2. 请求上传
    const uploadInfo = await requestUpload(file, 'user_image');
    
    // 3. 检查秒传
    if (uploadInfo.instant_upload) {
      console.log('秒传成功！使用UUID映射');
      return {
        success: true,
        instant: true,
        url: uploadInfo.existing_file_url  // UUID格式的访问URL
      };
    }
    
    // 4. 根据模式上传
    if (uploadInfo.mode === 'one_time_token') {
      // 小文件直接上传
      const result = await uploadFile(file, uploadInfo.upload_url);
      console.log('上传成功！');
      return {
        success: true,
        instant: false,
        url: result.file_url
      };
    } else {
      // 超大文件分片上传
      await uploadLargeFile(file, uploadInfo);
      console.log('分片上传完成！');
      return {
        success: true,
        instant: false
      };
    }
    
  } catch (error) {
    console.error('上传失败:', error);
    throw error;
  }
}

// 使用示例
const fileInput = document.querySelector('#file-input');
fileInput.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  
  try {
    const result = await uploadFileComplete(file);
    alert(`上传成功！${result.instant ? '（秒传）' : ''}`);
  } catch (error) {
    alert('上传失败: ' + error.message);
  }
});
```

---

## 4. 通过UUID访问文件

### 接口信息

- **URL**: `/api/storage/file/{uuid}`
- **方法**: `GET`
- **需要鉴权**: 是（Bearer Token）

### 功能说明

通过UUID访问文件，系统会：
1. 验证用户Token
2. 检查权限表（`file_access_permissions`）
3. 查询UUID映射表获取物理文件路径
4. 从MinIO读取文件并返回文件流

### 路径参数

- `uuid`: 文件的UUID标识（36位UUID字符串）

### 请求示例

```bash
curl -X GET "http://localhost:8080/api/storage/file/f5f23929-1689-4b04-98e7-0073fac1eea4" \
  -H "Authorization: Bearer {access_token}"
```

### 响应

- **成功**: 返回文件流（二进制数据）
  - Status: 200 OK
  - Content-Type: 文件的MIME类型
  - Content-Length: 文件大小
  - Cache-Control: public, max-age=31536000
  
- **无权限**: 
  ```json
  {
    "error": "无权访问此文件"
  }
  ```
  - Status: 403 Forbidden
  
- **文件不存在**:
  ```json
  {
    "error": "文件不存在"
  }
  ```
  - Status: 404 Not Found

### Fetch API 调用示例

```javascript
// 访问UUID文件
async function accessFileByUuid(uuid) {
  const accessToken = localStorage.getItem('access_token');
  
  const response = await fetch(
    `http://localhost:8080/api/storage/file/${uuid}`,
    {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${accessToken}`
      }
    }
  );
  
  if (!response.ok) {
    if (response.status === 403) {
      throw new Error('无权访问此文件');
    } else if (response.status === 404) {
      throw new Error('文件不存在');
    }
    throw new Error('访问失败');
  }
  
  // 获取文件blob
  const blob = await response.blob();
  return URL.createObjectURL(blob);
}

// 在页面中显示图片
async function displayImage(uuid) {
  try {
    const blobUrl = await accessFileByUuid(uuid);
    const img = document.createElement('img');
    img.src = blobUrl;
    document.body.appendChild(img);
  } catch (error) {
    console.error('显示失败:', error);
  }
}

// 在视频标签中播放
async function playVideo(uuid) {
  try {
    const blobUrl = await accessFileByUuid(uuid);
    const video = document.querySelector('video');
    video.src = blobUrl;
    video.play();
  } catch (error) {
    console.error('播放失败:', error);
  }
}

// 直接在img标签中使用（需要token在header中，仅支持fetch方式）
function displayImageDirectly(uuid) {
  const img = document.querySelector('#preview-img');
  // 注意：直接在img.src中无法传递Authorization header
  // 建议使用fetch获取blob后转为objectURL
}
```

---

## 5. 文件类型和大小限制

| 文件类型 | 大小范围 | 上传方式 | 预览支持 |
|---------|---------|---------|---------|
| 头像 | < 5MB | 一次性Token | 在线预览 |
| 图片 | < 100MB | 一次性Token | 在线预览 |
| 图片（大） | 100MB - 15GB | 一次性Token | 仅下载 |
| 视频 | < 15GB | 一次性Token | 在线预览 |
| 视频（大） | 15GB - 30GB | 一次性Token | 仅下载 |
| 文档 | < 15GB | 一次性Token | 仅下载 |
| 超大文件 | 15GB - 30GB | 预签名URL（分片） | 仅下载 |

---

## 存储路径规范

按照 `MinIO/data.md` 规范：

- **avatars**: `{user_id}.{ext}`
- **user-file**: `{user_id}/{type}/{timestamp}_{hash}_{filename}`
- **friends-file**: `{conversation_uuid}/{type}/{timestamp}_{hash}_{filename}`
- **group-file**: `{group_id}/{type}/{timestamp}_{hash}_{filename}`

type分类：
- `images/` - 图片文件
- `videos/` - 视频文件
- `files/` - 文档文件

---

## 错误处理

```javascript
try {
  const result = await uploadFileComplete(file);
} catch (error) {
  if (error.message.includes('Token无效')) {
    // Token过期或无效
    alert('请重新登录');
  } else if (error.message.includes('文件大小超过限制')) {
    // 文件太大
    alert('文件过大，无法上传');
  } else if (error.message.includes('哈希不匹配')) {
    // 文件损坏
    alert('文件已损坏，请重试');
  } else {
    // 其他错误
    alert('上传失败: ' + error.message);
  }
}
```

---

## 注意事项

1. **文件哈希计算**：必须在客户端计算SHA-256哈希，用于去重和完整性校验
2. **一次性Token**：每个Token只能使用一次，使用后自动失效
3. **有效期**：根据文件大小自动分配（5分钟-4小时）
4. **直连上传**：大文件直连MinIO，不占用后端带宽
5. **秒传功能**：相同哈希的文件会自动秒传，节省时间和带宽
6. **进度跟踪**：建议在前端显示上传进度（使用XMLHttpRequest或Fetch的progress事件）

---

## UUID映射机制详解

### 设计原理

采用**UUID映射表 + 权限表**实现跨用户文件去重：

```
用户A上传 test.jpg (哈希: abc123...)
  ├─ 物理存储: user-file/userA/images/xxx_abc123_test.jpg
  ├─ 生成UUID: f5f23929-1689-4b04-98e7-0073fac1eea4
  ├─ 映射表记录: UUID → 物理路径
  └─ 权限表记录: UUID + userA → owner

用户B上传相同文件 test.jpg (哈希: abc123...)
  ├─ 查询到已存在的UUID
  ├─ 秒传：无需重复上传物理文件
  ├─ 权限表记录: UUID + userB → owner
  └─ 返回相同的UUID访问URL

访问流程：
  用户A/B访问: /api/storage/file/{uuid}
  ├─ 验证Token
  ├─ 查询权限表（是否有访问权限）
  ├─ 查询映射表（获取物理路径）
  └─ 从MinIO读取并返回文件流
```

### 核心优势

1. **真正的跨用户去重**
   - 相同文件只存储一份物理副本
   - 节省存储空间50-90%

2. **统一的权限控制**
   - 基于数据库权限表，不依赖MinIO bucket策略
   - 支持灵活的权限授予和撤销

3. **用户隔离**
   - 每个用户有独立的file_key
   - 不会暴露其他用户的文件路径

4. **软删除支持**
   - 撤销权限时设置`revoked_at`
   - 物理文件保留直到所有权限都被撤销

### 数据库表结构

#### file_uuid_mapping（UUID映射表）
| 字段 | 说明 |
|------|------|
| uuid | 随机UUID，访问标识 |
| physical_file_key | 实际物理文件路径 |
| file_hash | SHA-256哈希（去重查询） |
| first_uploader_id | 首次上传者 |

#### file_access_permissions（权限表）
| 字段 | 说明 |
|------|------|
| file_uuid | 关联UUID |
| user_id | 授权用户 |
| access_type | owner/read |
| granted_by | upload/share/friend/group |
| revoked_at | 软删除时间 |

### 性能考量

- 首次上传：1次数据库查询（< 2ms）
- 秒传：2次数据库写入（< 5ms）
- 文件访问：2次数据库查询（< 8ms）
- 高并发支持：约2000次/秒文件访问

